{"ast":null,"code":"/**\r\n * Arreglo con los elementos de prioridad, contiene un arreglo con una serie de elementos, y la prioridad para cualquier elemento en el arreglo.\r\n */\nlet arrPrioridad = [{\n  token: ['*', '/'],\n  prioridad: 2\n}, {\n  token: ['+', '-'],\n  prioridad: 1\n}, {\n  token: ['('],\n  prioridad: 0\n}, {\n  token: [')'],\n  prioridad: -1\n}];\n/**\r\n * Método que nos permite verificar si un valor existe en el arreglo de Prioridad, retornando el elemento con los datos de prioridad y el valor.\r\n * @param value Valor a evaluar, (valor a verificar si existe en el arreglo de Prioridad).\r\n * @param arrKeys Arreglo de prioridad en el cual se desea evaluar el valor.\r\n * @returns undefined en el caso de que el valor no coincida, o retorna el elemento con los datos de prioridad y el valor.\r\n */\n\nfunction isKey(value, arrKeys) {\n  for (let i = 0; i < arrKeys.length; i++) {\n    const {\n      token,\n      prioridad\n    } = arrKeys[i];\n\n    for (let j = 0; j < token.length; j++) {\n      if (value == token[j]) {\n        return {\n          token: token,\n          prioridad: prioridad,\n          value: value\n        };\n      }\n    }\n  }\n\n  return undefined;\n}\n/**\r\n * Método que nos permite obtener apilar de acuerdo al algoritmo de prioridad, en el caso de postFijo la\r\n * condición es si el elemento es mayor a la prioridad, en caso de ser menor o igual se sigue buscando.\r\n * @param pila Arreglo que hará la función de pila.\r\n * @param key Elemento a evaluar.\r\n * @param result Arreglo en donde se almacenará el valor en el caso de sacar elementos de la pila.\r\n */\n\n\nfunction algoritmoApilarPostFijo(pila, key, result) {\n  let lastItem = pila.pop();\n\n  if (lastItem) {\n    if (key.prioridad > lastItem.prioridad) {\n      pila.push(lastItem);\n    } else {\n      result.push(lastItem.value);\n      algoritmoApilarPostFijo(pila, key, result);\n    }\n  }\n}\n/**\r\n * Método que nos permite obtener apilar de acuerdo al algoritmo de prioridad, en el caso de preFijo la\r\n * condición es si el elemento es mayor o igual a la prioridad, en caso de ser menor se sigue buscando.\r\n * @param pila Arreglo que hará la función de pila.\r\n * @param key Elemento a evaluar.\r\n * @param result Arreglo en donde se almacenará el valor en el caso de sacar elementos de la pila.\r\n */\n\n\nfunction algoritmoApilarPreFijo(pila, key, result) {\n  let lastItem = pila.pop();\n\n  if (lastItem) {\n    if (key.prioridad < lastItem.prioridad) {\n      result.push(lastItem.value);\n      algoritmoApilarPreFijo(pila, key, result);\n    } else {\n      pila.push(lastItem);\n    }\n  }\n}\n/**\r\n * Método que nos permite desapilar buscando un elemento de prioridad, ademas de dar la opción si agregar el elemento al resultado.\r\n * @param pila Arreglo que funciona como pila para desapilar.\r\n * @param result Arreglo donde se agregan los elementos resultantes.\r\n * @returns 0 en caso de acabar el método correctamente.\r\n */\n\n\nfunction buscarElementoPrioridad(pila, result, prioridadABuscar, agregarElementoPrioridad) {\n  for (let i = pila.length - 1; i >= 0; i--) {\n    let element = pila.pop();\n\n    if (element.prioridad == prioridadABuscar) {\n      if (agregarElementoPrioridad) result.push(element.value);\n      break;\n    } else {\n      result.push(element.value);\n    }\n  }\n\n  return 0;\n}\n/**\r\n * Toma una matriz de objetos y devuelve una cadena de valores de los objetos, separados por una\r\n * cadena.\r\n * @param arr - Array<any> = La matriz que desea convertir en una cadena.\r\n * @param {string} separador - el separador que quieres usar\r\n * @returns la cadena.\r\n */\n\n\nfunction pilaToString(arr, separador) {\n  let data = '';\n  arr.forEach(key => {\n    data += key.value + ' ';\n  });\n  data = data.trim().replaceAll(' ', separador);\n  return data;\n}\n\nexport let tableInFijoToPosFijo = [];\n/**\r\n * Método que nos permite pasar una cadena de infija a postfija.\r\n * @param data cadena a evaluar.\r\n */\n\nexport function inFijoAPosFijo(arrData) {\n  tableInFijoToPosFijo = []; //Generamos la pila a usar para desarrollar el algoritmo\n\n  let pila = new Array(); //Generamos el arreglo resultante\n\n  let result = new Array();\n\n  for (let i = 0; i < arrData.length; i++) {\n    let value = arrData[i];\n    let key = isKey(value, arrPrioridad);\n\n    if (key) {\n      if (pila.length != 0) {\n        if (key.prioridad == -1) {\n          buscarElementoPrioridad(pila, result, 0, false);\n          tableInFijoToPosFijo.push({\n            value: value,\n            pila: pilaToString(pila, ', '),\n            result: result.toString().replaceAll(',', ' ')\n          });\n          continue;\n        } else if (key.prioridad != 0) {\n          algoritmoApilarPostFijo(pila, key, result);\n        }\n      }\n\n      pila.push(key);\n    } else {\n      result.push(value);\n    }\n\n    let data = {\n      value: value,\n      pila: pilaToString(pila, ', '),\n      result: result.toString().replaceAll(',', ' ')\n    };\n    tableInFijoToPosFijo.push(data);\n  } // Sacamos los elementos de la pila y los agregamos al resultado\n\n\n  pila.reverse().forEach(element => {\n    result.push(element.value);\n  });\n  tableInFijoToPosFijo.push({\n    value: '',\n    pila: '',\n    result: result.toString().replaceAll(',', ' ')\n  });\n  return result.toString().replaceAll(',', ' ').trim();\n}\nexport let tableInFijoToPreFijo = [];\n/**\r\n * Método que nos permite pasar una cadena de infija a postfija.\r\n * @param data cadena a evaluar.\r\n */\n\nexport function inFijoAPreFijo(arrData) {\n  tableInFijoToPreFijo = [];\n\n  if (arrData.length > 0) {\n    tableInFijoToPreFijo.push({\n      value: '',\n      pila: '',\n      result: arrData.toString().replaceAll(',', ' ')\n    });\n  } //Generamos la pila a usar para desarrollar el algoritmo\n\n\n  let pila = new Array(); //Generamos el arreglo resultante\n\n  let result = new Array();\n\n  for (let i = 0; i < arrData.length; i++) {\n    let value = arrData[i];\n    let key = isKey(value, arrPrioridad);\n\n    if (key) {\n      if (pila.length != -1) {\n        if (key.prioridad == 0) {\n          buscarElementoPrioridad(pila, result, -1, false);\n          tableInFijoToPreFijo.push({\n            value: value,\n            pila: pilaToString(pila, ', '),\n            result: result.toString().replaceAll(',', ' ')\n          });\n          continue;\n        } else if (key.prioridad != -1) {\n          algoritmoApilarPreFijo(pila, key, result);\n        }\n      }\n\n      pila.push(key);\n    } else {\n      result.push(value);\n    }\n\n    let data = {\n      value: value,\n      pila: pilaToString(pila, ', '),\n      result: result.toString().replaceAll(',', ' ')\n    };\n    tableInFijoToPreFijo.push(data);\n  }\n\n  pila.reverse().forEach(element => {\n    result.push(element.value);\n  });\n  tableInFijoToPreFijo.push({\n    value: '',\n    pila: '',\n    result: result.toString().replaceAll(',', ' ')\n  });\n  result.reverse();\n  tableInFijoToPreFijo.push({\n    value: '',\n    pila: '',\n    result: result.toString().replaceAll(',', ' ')\n  });\n  return result.toString().replaceAll(',', ' ').trim();\n}","map":null,"metadata":{},"sourceType":"module"}