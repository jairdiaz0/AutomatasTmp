{"ast":null,"code":"let arrTokensLexico = [{\n  token: 'Comment',\n  type: 'Comentario',\n  er: /^[#](.)*$/\n}, {\n  token: 'New_Line',\n  type: 'Salto de Línea',\n  er: /^\\n*$/\n}, {\n  token: 'String',\n  type: 'Cadena',\n  er: /^((['](.)*['])|([\"](.)*[\"]))$/\n}, {\n  token: ',',\n  type: 'Símbolo (\",\")',\n  er: /^,$/\n}, {\n  token: ':',\n  type: 'Símbolo (\" : \")',\n  er: /^:$/\n}, {\n  token: '(',\n  type: 'Símbolo (\" ( \")',\n  er: /^\\($/\n}, {\n  token: ')',\n  type: 'Símbolo (\" ) \")',\n  er: /^\\)$/\n}, {\n  token: '{',\n  type: 'Símbolo (\" { \")',\n  er: /^\\{$/\n}, {\n  token: '}',\n  type: 'Símbolo (\" } \")',\n  er: /^\\}$/\n}, {\n  token: '[',\n  type: 'Símbolo (\" [ \")',\n  er: /^\\[$/\n}, {\n  token: ']',\n  type: 'Símbolo (\" ] \")',\n  er: /^\\]$/\n}, {\n  token: 'Import',\n  type: 'Palabra Reservada',\n  er: /^importar$/\n}, {\n  token: 'Class',\n  type: 'Palabra Reservada',\n  er: /^clase$/\n}, {\n  token: 'Def',\n  type: 'Palabra Reservada',\n  er: /^definir$/\n}, {\n  token: 'Return',\n  type: 'Palabra Reservada',\n  er: /^retornar$/\n}, {\n  token: 'Execute',\n  type: 'Palabra Reservada',\n  er: /^ejecutar$/\n}, {\n  token: 'Get',\n  type: 'Palabra Reservada',\n  er: /^obtener$/\n}, {\n  token: 'If',\n  type: 'Palabra Reservada',\n  er: /^si$/\n}, {\n  token: 'Else',\n  type: 'Palabra Reservada',\n  er: /^sino$/\n}, {\n  token: 'While',\n  type: 'Palabra Reservada',\n  er: /^mientras$/\n}, {\n  token: 'For',\n  type: 'Palabra Reservada',\n  er: /^repite$/\n}, {\n  token: 'Print',\n  type: 'Palabra Reservada',\n  er: /^imprime$/\n}, {\n  token: 'Input',\n  type: 'Palabra Reservada',\n  er: /^ingresa$/\n}, {\n  token: 'OR',\n  type: 'Operador Relacional',\n  er: /^((==)|(<=?)|(>=?)|(!=))$/\n}, {\n  token: 'OAs',\n  type: 'Operador de Asignación',\n  er: /^[=]$/\n}, {\n  token: 'OA',\n  type: 'Operador aritmetico',\n  er: /^[\\/|+|\\-|*]$/\n}, {\n  token: 'Var',\n  type: 'Palabra Reservada',\n  er: /^var$/\n}, {\n  //Números Enteros\n  token: 'Int',\n  type: 'Entero',\n  er: /^(([-+]\\d|\\d)\\d*)$/\n}, {\n  //Números Dobles\n  token: 'Double',\n  type: 'Doble',\n  er: /^(([-+]\\d|\\d)\\d*[.]\\d+)$/\n}, {\n  token: 'Boolean',\n  type: 'Booleano',\n  er: /^(verdadero)|(falso)$/\n}, {\n  token: 'Void',\n  type: 'Vacio',\n  er: /^vacio$/\n}, {\n  token: 'IdClase',\n  type: 'Clase',\n  er: /^([A-Z][\\w]*)$/\n}, {\n  //Variables | Métodos\n  token: 'Id',\n  type: 'Identificador',\n  er: /^([a-z][\\w]*)$/\n}];\nlet table = {\n  headers: ['Linea', 'Valor', 'Tipo'],\n  tokens: new Array(),\n  errors: new Array()\n};\nlet ignore = [''];\nexport function getLexicoTable() {\n  return table;\n}\nexport function initLexico(lines) {\n  table.tokens = [];\n  table.errors = [];\n  checkValue(lines);\n  return table.tokens;\n}\n/**\r\n * Nos permite obtener obtener el valor ingresado separando las palabras por Lineas, eliminando los \\t innecesarios\r\n * @param lines String con las lineas escritas.\r\n * @param tokensLexico Arreglo de tokens en donde guardaremos los tokens de las palabras.\r\n * @returns Array <token> con los tokens de cada palabra.\r\n */\n\nexport function checkValue(lines) {\n  if (lines.length > 0) {\n    checkLines(lines.replaceAll('\\t', '').split('\\n'));\n  }\n}\n\nfunction checkLines(lines) {\n  let bandera = true;\n\n  for (let index in lines) {\n    if (lines[index].length > 0) {\n      if (!checkLine(lines[index], Number(index) + 1)) {\n        bandera = false;\n        break;\n      }\n    }\n  }\n}\n\nfunction checkLine(line, indexLine) {\n  let words = new Array();\n  let iComment = line.indexOf('#');\n\n  if (iComment > 0) {\n    words = line.substring(0, iComment).split(' ');\n    words.push(line.substring(iComment, line.length));\n  } else if (iComment == 0) {\n    words.push(line);\n  } else {\n    if (line.indexOf(\"'\") >= 0) {\n      getStrings(line, words);\n    } else {\n      words = line.split(' ');\n    }\n  }\n\n  return checkWords(words, indexLine);\n}\n\nfunction getStrings(line, words) {\n  const lineArr = line.split(' ');\n  let flag = false;\n  let comment = \"\";\n\n  if (line.indexOf(\"'\") >= 0) {\n    lineArr.forEach(word => {\n      if (word.charAt(0) == \"'\" && !flag) {\n        flag = true;\n        comment = \"\";\n      }\n\n      if (flag) {\n        if (comment != \"\") {\n          comment += ' ';\n        }\n\n        comment += word;\n\n        if (word.charAt(word.length - 1) == \"'\") {\n          flag = false;\n          words.push(comment);\n        }\n      } else {\n        words.push(word);\n      }\n    });\n  } else {\n    words = lineArr;\n  }\n}\n\nfunction checkWords(words, indexLine) {\n  words.push('\\n');\n\n  for (const index in words) {\n    let word = words[index];\n\n    if (checkIgnore(word)) {} else if (!checkTokens(word, indexLine)) {}\n  }\n\n  return true;\n}\n\nfunction checkTokens(word, indexA) {\n  for (const index in arrTokensLexico) {\n    const {\n      er,\n      token,\n      type\n    } = arrTokensLexico[index];\n\n    if (er.test(word)) {\n      // tokens += 'Linea: ' + indexA + '     -     ' + word + ' - > ' + type + \"\\n\";\n      table.tokens.push({\n        tokenLex: arrTokensLexico[index],\n        line: String(indexA),\n        value: word\n      });\n      return true;\n    }\n  }\n\n  const error = {\n    tokenLex: {\n      token: 'NaN',\n      type: 'Error Tipo No Válido',\n      er: /^$/\n    },\n    line: String(indexA),\n    value: word\n  };\n  table.tokens.push(error);\n  table.errors.push(error);\n  return false;\n}\n\nfunction checkIgnore(word) {\n  for (const index in ignore) {\n    if (ignore[index] == word) {\n      return true;\n    }\n  }\n\n  return false;\n}","map":null,"metadata":{},"sourceType":"module"}