{"ast":null,"code":"import { EventEmitter } from '@angular/core';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../../shared/components/code-text-area/code-text-area.component\";\nexport let ExtraComponent = /*#__PURE__*/(() => {\n  class ExtraComponent {\n    constructor() {\n      //Cadena a mostrar en el textArea del resultado\n      this.result = '';\n      /**\r\n       * Arreglo con los elementos de prioridad, contiene un arreglo con una serie de elementos, y la prioridad para cualquier elemento en el arreglo.\r\n       */\n\n      this.arrPrioridad = [{\n        token: ['*', '/'],\n        prioridad: 2\n      }, {\n        token: ['+', '-'],\n        prioridad: 1\n      }, {\n        token: ['('],\n        prioridad: 0\n      }, {\n        token: [')'],\n        prioridad: -1\n      }];\n      this.$data = new EventEmitter();\n    }\n\n    ngOnInit() {\n      this.$data.subscribe(data => {\n        this.result = 'InFija ->\\n' + data + '\\n';\n        this.inFijoAPostFijo(data);\n        this.inFijoAPreFijo(data);\n      });\n    }\n    /**\r\n     * Método que nos permite verificar si un valor existe en el arreglo de Prioridad, retornando el elemento con los datos de prioridad y el valor.\r\n     * @param value Valor a evaluar, (valor a verificar si existe en el arreglo de Prioridad).\r\n     * @param arrKeys Arreglo de prioridad en el cual se desea evaluar el valor.\r\n     * @returns undefined en el caso de que el valor no coincida, o retorna el elemento con los datos de prioridad y el valor.\r\n     */\n\n\n    isKey(value, arrKeys) {\n      for (let i = 0; i < arrKeys.length; i++) {\n        const {\n          token,\n          prioridad\n        } = arrKeys[i];\n\n        for (let j = 0; j < token.length; j++) {\n          if (value == token[j]) {\n            return {\n              token: token,\n              prioridad: prioridad,\n              value: value\n            };\n          }\n        }\n      }\n\n      return undefined;\n    }\n    /**\r\n     * Método que nos permite obtener apilar de acuerdo al algoritmo de prioridad, en el caso de postFijo la\r\n     * condición es si el elemento es mayor a la prioridad, en caso de ser menor o igual se sigue buscando.\r\n     * @param pila Arreglo que hará la función de pila.\r\n     * @param key Elemento a evaluar.\r\n     * @param result Arreglo en donde se almacenará el valor en el caso de sacar elementos de la pila.\r\n     */\n\n\n    algoritmoApilarPostFijo(pila, key, result) {\n      let lastItem = pila.pop();\n\n      if (lastItem) {\n        if (key.prioridad > lastItem.prioridad) {\n          pila.push(lastItem);\n        } else {\n          result.push(lastItem.value);\n          this.algoritmoApilarPostFijo(pila, key, result);\n        }\n      }\n    }\n    /**\r\n     * Método que nos permite obtener apilar de acuerdo al algoritmo de prioridad, en el caso de preFijo la\r\n     * condición es si el elemento es mayor o igual a la prioridad, en caso de ser menor se sigue buscando.\r\n     * @param pila Arreglo que hará la función de pila.\r\n     * @param key Elemento a evaluar.\r\n     * @param result Arreglo en donde se almacenará el valor en el caso de sacar elementos de la pila.\r\n     */\n\n\n    algoritmoApilarPreFijo(pila, key, result) {\n      let lastItem = pila.pop();\n\n      if (lastItem) {\n        if (key.prioridad < lastItem.prioridad) {\n          result.push(lastItem.value);\n          this.algoritmoApilarPreFijo(pila, key, result);\n        } else {\n          pila.push(lastItem);\n        }\n      }\n    }\n    /**\r\n     * Método que nos permite desapilar buscando un elemento de prioridad, ademas de dar la opción si agregar el elemento al resultado.\r\n     * @param pila Arreglo que funciona como pila para desapilar.\r\n     * @param result Arreglo donde se agregan los elementos resultantes.\r\n     * @returns 0 en caso de acabar el método correctamente.\r\n     */\n\n\n    buscarElementoPrioridad(pila, result, prioridadABuscar, agregarElementoPrioridad) {\n      for (let i = pila.length - 1; i >= 0; i--) {\n        let element = pila.pop();\n\n        if (element.prioridad == prioridadABuscar) {\n          if (agregarElementoPrioridad) result.push(element.value);\n          break;\n        } else {\n          result.push(element.value);\n        }\n      }\n\n      return 0;\n    }\n    /**\r\n     * Método que nos permite pasar una cadena de infija a postfija.\r\n     * @param data cadena a evaluar.\r\n     */\n\n\n    inFijoAPostFijo(data) {\n      //Separamos por espacios la información ingresada\n      let arrData = data.split(' ').filter(Boolean); //Generamos la pila a usar para desarrollar el algoritmo\n\n      let pila = new Array(); //Generamos el arreglo resultante\n\n      let result = new Array();\n\n      for (let i = 0; i < arrData.length; i++) {\n        let value = arrData[i];\n        let key = this.isKey(value, this.arrPrioridad);\n\n        if (key) {\n          if (pila.length != 0) {\n            if (key.prioridad == -1) {\n              this.buscarElementoPrioridad(pila, result, 0, false);\n              continue;\n            } else if (key.prioridad != 0) {\n              this.algoritmoApilarPostFijo(pila, key, result);\n            }\n          }\n\n          pila.push(key);\n        } else {\n          result.push(value);\n        }\n      } // Sacamos los elementos de la pila y los agregamos al resultado\n\n\n      pila.reverse().forEach(element => {\n        result.push(element.value);\n      }); // Mostramos el arreglo resultante en forma de texto.\n\n      this.result += 'PostFija ->\\n' + result.toString().replaceAll(',', ' ') + '\\n';\n    }\n    /**\r\n     * Método que nos permite pasar una cadena de infija a postfija.\r\n     * @param data cadena a evaluar.\r\n     */\n\n\n    inFijoAPreFijo(data) {\n      //Separamos por espacios la información ingresada\n      let arrData = data.split(' ').reverse().filter(Boolean);\n      console.log('Data sin espacios -> ', arrData.toString().replaceAll(',', ' ')); // console.log('ArrData -> ', arrData)\n      //Generamos la pila a usar para desarrollar el algoritmo\n\n      let pila = new Array(); //Generamos el arreglo resultante\n\n      let result = new Array();\n\n      for (let i = 0; i < arrData.length; i++) {\n        let value = arrData[i];\n        let key = this.isKey(value, this.arrPrioridad);\n\n        if (key) {\n          if (pila.length != -1) {\n            if (key.prioridad == 0) {\n              this.buscarElementoPrioridad(pila, result, -1, false);\n              continue;\n            } else if (key.prioridad != -1) {\n              this.algoritmoApilarPreFijo(pila, key, result);\n            }\n          }\n\n          pila.push(key);\n        } else {\n          result.push(value);\n        }\n      } // console.log('Pila -> ', pila)\n\n\n      pila.reverse().forEach(element => {\n        result.push(element.value);\n      }); // console.log('Result', result)\n\n      this.result += 'PreFija ->\\n' + result.reverse().toString().replaceAll(',', ' ') + '\\n'; // console.log(result.reverse().toString().replaceAll(',', ' '))\n    }\n\n  }\n\n  ExtraComponent.ɵfac = function ExtraComponent_Factory(t) {\n    return new (t || ExtraComponent)();\n  };\n\n  ExtraComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: ExtraComponent,\n    selectors: [[\"app-extra\"]],\n    decls: 7,\n    vars: 2,\n    consts: [[1, \"container-fluid\", \"g-5\"], [1, \"row\"], [1, \"col-6\"], [3, \"$data\"], [1, \"col-6\", \"mt-5\", \"g-5\"], [\"disabled\", \"\", \"cols\", \"30\", \"rows\", \"10\", 1, \"form-control\", \"text-dark\", \"mt-4\"]],\n    template: function ExtraComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1)(2, \"div\", 2);\n        i0.ɵɵelement(3, \"app-code-text-area\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"div\", 4)(5, \"textarea\", 5);\n        i0.ɵɵtext(6);\n        i0.ɵɵelementEnd()()()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"$data\", ctx.$data);\n        i0.ɵɵadvance(3);\n        i0.ɵɵtextInterpolate(ctx.result);\n      }\n    },\n    dependencies: [i1.CodeTextAreaComponent],\n    styles: [\"*[_ngcontent-%COMP%]{color:#fff}\"]\n  });\n  return ExtraComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}